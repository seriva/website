---
title: "Bye Brunch & Babel. Hello pure ES6!"
date: 2019-02-19
tags: ["Development"]
draft: false
---

After reading this [article](https://salomvary.com/es6-modules-in-browsers.html) I thought it would be cool to investigate and see if I could switch [QDFPA](https://www.luukvanvenrooij.nl/project/qdfpa/) fully to ES6 for both development and release.

A quick view [here](https://kangax.github.io/compat-table/es6/) and I knew that from a language feature perspective I would be okay since QDFPA is only running on the latest Chrome and Firefox because of the WebGL 2.0 requirement.

However using the external libraries with ES6 modules in the browser was a bit of a different story. Not all of them are written in ES6 or just lack an ES6 distribution for easy import. I could not find a solution I liked so I settled for my own simple one. I added  the following extra entries to package.json:

```json
  "dependencyPaths": [
    "node_modules/gl-matrix/gl-matrix-min.js",
    "node_modules/maquette/dist/maquette.umd.min.js",
    "node_modules/velocity-animate/velocity.min.js",
    "node_modules/jss/dist/jss.min.js",
    "node_modules/jss-preset-default/dist/jss-preset-default.min.js",
    "node_modules/jss-plugin-global/dist/jss-plugin-global.min.js"
  ],
  "dependencyGlobalNames": [
    "glMatrix",
    "maquette",
    "Velocity",
    "jss",
    "jssPresetDefault",
    "jssPluginGlobal"
  ]
```

The `dependencyPaths` entries are used to bundle and minify the libs UMD distributions in one UMD library bundle which is imported like normal in the HTML header. Since all these libraries now live in the global space like its 2010 I'm using the `dependencyGlobalNames` entries to generate a special ES6 import file which basicly exports the globals and removes them from the global space:

```js
const glMatrix = window.glMatrix;
delete window.glMatrix;
export { glMatrix };

const maquette = window.maquette;
delete window.maquette;
export { maquette };

...
```

Using this import I could now access all libraries without poluting the global space.

As for changes to the actual code there was surpisingly little todo:

1. Add the js extension behind all import statements. Otherwise Chrome and Firefox will not resolve the files.
2. Import the main.js as an ES6 module:
    ```js
    <script type="module" src="src/main.js"></script>
    ```
3. Change the library specific code to use the generated library import.

And that was it for running the code as pure ES6 modules in the browser!

With achieving this I decided to make some changes to the core of the project. In development there was now no need anymore for transpiling, bundling and sourcemaps. So I decided to remove Brunch/Bable and replace the build-in dev server with [live-server](https://github.com/tapio/live-server). Finally for quick debugging in the browser I added some extra code in index.html to quickly catch and print out any runtime errors:

```js
window.onerror = function(msg, url, line, column, error) {
document.body.style.padding = "5px";
document.body.style.overflow = "scroll";
document.body.innerHTML =
    "Error (" +
    line +
    "," +
    column +
    "): " +
    msg +
    "<br />Stack: " +
    error.stack;
return false;
};
```

When it comes to using ESLint I decided that during development I much more value the quick reload and faster iteration then dealing with fixing linting issue. I still use ESLint periodicly to check my code before committing but I dont need it constantly during development to hold my hand.

The final change was to introduce [Rollup](https://rollupjs.org/guide/en) to bundle and minify the code as a single module for release. This so the app loading doesn`t slow because of the seperate ES6 module files.

And thats it for swithing QDFPA fully to ES6 in development and production!